trigger: none

parameters:
  - name: repository_dependency
    type: string
    default: something
  - name: release_target
    type: string
    default: whatever
  - name: ignore_stage_failure
    type: boolean
    default: false
  - name: serversObjects
    type: object
    default:
      - server: 'HOST_3DSpace1'
        title: 'App Server 1'
        deployment_tasks: 'deployAll'
        wrap_deployment_instructions: 'true'
      - server: 'HOST_3DSpace2'
        title: 'App Server 2'
        deployment_tasks: 'only_Ctrlm only_Web'
        wrap_deployment_instructions: 'true'
        #in_sequence: 'true'
      - server: 'HOST_Integrations1'
        title: 'Integration Server Apps 1'
        deployment_tasks: 'only_Web'
        wrap_deployment_instructions: 'true'
        dependency: 'HOST_3DSpace1'
      - server: 'HOST_Integrations2'
        title: 'Integration Server Apps 2'
        deployment_tasks: 'only_Web'
        wrap_deployment_instructions: 'true'
        #in_sequence: 'true'
      - server: 'HOST_Widget'
        title: 'Widget Host server'
        deployment_tasks: 'only_Web deployWidget deployWidgetWeb'
        wrap_deployment_instructions: 'true'
        dependency: 'HOST_3DSpace1'

pool:
  name: Default
  vmImage: 'LP15-U33-DSA'
  
stages:
  - stage: 'Check_runners'
    jobs:
    - job: checkRunnerHealth
      displayName: 'Check runner(s) are online'
      steps:
      - task: PowerShell@2
        displayName: 'query runner(s)'
        env:
            REPOSITORY_NAME: $(Build.Repository.Name) 
            SERVER_OBJECTS: ${{ convertToJson(parameters.serversObjects) }}
        inputs:
            targetType: 'inline'
            script: |
                # STEP 1: Loop through the parameters and extract the server names into a table
                $serverObjectsJson = ${env:SERVER_OBJECTS}
                $serversObjects = ConvertFrom-Json $serverObjectsJson

                $serverNames = @()
                $names = "azl-adln9371", "VM-U33-DSA", "unknown"
                
                foreach ($serverObject in $serversObjects) {
                    $serverName = $serverObject.server
                    $serverNames += [Environment]::GetEnvironmentVariable("$serverName")
                    
                    # You can perform further actions with the serverName here
                }
                
                Write-Host "Server names: $serverNames"
                Write-Host "names: $names"

  - ${{ each environmentObject in parameters.serversObjects }} :
    - stage: 'Deploy_${{ environmentObject.server }}'
      #${{ if ne(environmentObject.in_sequence, 'true') }}:
      #  dependsOn: [] # Let's remove the implicit dependencies between stages. Each stage shall be autonomous when possible.
      ${{ if ne(environmentObject.dependency, '') }}:
        dependsOn: 'Deploy_${{ environmentObject.dependency }}'
      jobs:
      - job: DeployGitHubWorkflow
        displayName: 'Deploy on ${{ environmentObject.title }}'
        continueOnError: ${{ parameters.ignore_stage_failure }}
        pool:
          vmImage: 'ubuntu-latest'
        steps:
        - checkout: none  # Disable automatic checkout. Here we rely on GitHub workflow to do that. This workflow is just an event dispatcher



        # TODO: we might need a task that will smartly identify if the server has to be shutted down, based on what is the selected 'environmentObject.deployment_tasks'


        # TODO: if we loop, this task should be taken out of the stage, because there is no need to run it each time
        - task: PowerShell@2
          displayName: 'Setup runtime Environment Variables'
          name: environment_setup
          inputs:
            targetType: 'inline'
            script: |
              Write-Host "This is a task running to deploy"
        
          